import sparse_ir
import xprec # Make sure xprec is install for good accuracy
import numpy as np

# max line continuation is 255 for Fortran >= 2003,
# 39 for Fortran95.
# For safety, we stick to Fortran95.
MAX_CONTINUATION_LINE = 39
NLINE = MAX_CONTINUATION_LINE - 2

class BasisInfo:
    def __init__(self, nlambda: int, ndigit: int) -> None:
        lambda_ = 10.0 ** nlambda
        eps = 1/10.0 ** ndigit
        kernel = sparse_ir.LogisticKernel(lambda_)
        sve_result = sparse_ir.compute_sve(kernel, eps)

        self.basis_f = sparse_ir.DimensionlessBasis("F", lambda_, eps, kernel=kernel, sve_result=sve_result)
        self.basis_b = sparse_ir.DimensionlessBasis("B", lambda_, eps, kernel=kernel, sve_result=sve_result)
        self.s = self.basis_f.s
        self.size = self.s.size

        # Sampling points:
        #   Add tau = 0, beta to sampling points (for Matsubara summation)
        self.tau = np.unique(np.hstack([-1, self.basis_f.default_tau_sampling_points(), 1]))
        self.freq_f = self.basis_f.default_matsubara_sampling_points()
        self.freq_b = self.basis_b.default_matsubara_sampling_points()
        self.omega = np.unique(np.hstack([-1, self.basis_f.default_omega_sampling_points(), 1]))
        self.ntau = self.tau.size
        self.nfreq_f = self.freq_f.size
        self.nfreq_b = self.freq_b.size
        self.nomega = self.omega.size
        self.ntau_reduced = self.ntau //2 + 1
        self.nfreq_f_reduced = self.nfreq_f //2 + 1
        self.nfreq_b_reduced = self.nfreq_b //2 + 1
        self.nomega_reduced = self.nomega //2 + 1

        # Transformation matrix
        self.u = self.basis_f.u(self.tau).T
        self.uhat_f = self.basis_f.uhat(self.freq_f).T
        self.uhat_b = self.basis_b.uhat(self.freq_b).T
        self.v = self.basis_f.v(self.omega).T


def _str(value):
    if isinstance(value, float):
        return f"{value:.16e}".replace('e', 'd')
    elif type(value) in [int, np.int64]:
        return str(value)
    else:
        raise RuntimeError("Invalid type: " + str(type(value)))


def run(nlambda_list, ndigit_list):
    bases = {}

    for nlambda in nlambda_list:
        for ndigit in ndigit_list:
            bases[(nlambda, ndigit)] = BasisInfo(nlambda, ndigit)

    nlambda_str = ' '.join(map(str, nlambda_list))
    ndigit_str = ' '.join(map(str, ndigit_list))
    print(
f"""\
! Precomputed data of IR for a parameter matrix of
! nlambda = {nlambda_str} and ndigit = {ndigit_str}.
! This file was automatically generated:
!   python3 mk_preset.py --nlambda {nlambda_str} --ndigit {ndigit_str} > sparse_ir_preset.f90
! Do not edit this file manually.
!
module sparse_ir_preset
    use sparse_ir
    implicit none
""")
    for nlambda in nlambda_list:
        for ndigit in ndigit_list:
            b = bases[(nlambda, ndigit)]
            sig = f"nlambda{nlambda}_ndigit{ndigit}"
            print(
f"""\
    double precision :: s_{sig}({b.size})
    double precision :: tau_{sig}({b.ntau})
    integer :: freq_f_{sig}({b.nfreq_f})
    integer :: freq_b_{sig}({b.nfreq_b})
    double precision :: omega_{sig}({b.nomega})
    double precision :: u_r_{sig}({b.ntau_reduced} * {b.size})
    double precision :: uhat_f_r_{sig}({b.nfreq_f_reduced} * {b.size})
    double precision :: uhat_b_r_{sig}({b.nfreq_b_reduced} * {b.size})
    double precision :: v_r_{sig}({b.nomega_reduced} * {b.size})
"""
            )

    print(
"""\
    contains

    function mk_ir_preset(nlambda, ndigit, beta) result(obj)
        integer, intent(in) :: nlambda, ndigit
        double precision, intent(in) :: beta
        type(IR) :: obj
""")

    for nlambda in nlambda_list:
        for ndigit in ndigit_list:
            print(
f"""\
        if (nlambda == {nlambda} .and. ndigit == {ndigit}) then
            obj = mk_nlambda{nlambda}_ndigit{ndigit}(beta)
            return
        end if
"""
            )


    print(
"""\
        stop "Invalid parameters"
    end function
"""
            )

    for nlambda in nlambda_list:
        for ndigit in ndigit_list:
            print_data(nlambda, ndigit, bases[(nlambda, ndigit)])

    print("end")


def print_data(nlambda, ndigit, b):
    sig = f"nlambda{nlambda}_ndigit{ndigit}"
    print(
f"""
    function mk_nlambda{nlambda}_ndigit{ndigit}(beta) result(obj)
        double precision, intent(in) :: beta
        type(IR) :: obj
        complex(kind(0d0)), allocatable :: u(:, :), uhat_f(:, :), uhat_b(:, :), v(:, :), spr(:, :)
        integer, parameter :: size = {b.size}, ntau = {b.ntau}, nfreq_f = {b.nfreq_f}, nfreq_b = {b.nfreq_b}, nomega = {b.nomega}
        integer, parameter :: nlambda = {nlambda}, ndigit = {ndigit}
        integer, parameter :: ntau_reduced = ntau/2+1, nfreq_f_reduced = nfreq_f/2+1, nfreq_b_reduced = nfreq_b/2+1
        integer, parameter :: nomega_reduced = nomega/2+1
        double precision, parameter :: lambda = 1.d{nlambda}, eps = 1.d-{ndigit}

        integer :: itau, l, ifreq, iomega
""")
    for varname in ["s", "tau", "freq_f", "freq_b", "u_r", "uhat_f_r", "uhat_b_r", "omega", "v_r"]:
        print(8*" " + f"call init_{varname}_{sig}()")

    print(
f"""
        allocate(u(ntau, size))
        allocate(uhat_f(nfreq_f, size))
        allocate(uhat_b(nfreq_b, size))
        allocate(v(nomega, size))
        allocate(spr(nomega, size))

        ! Use the fact U_l(tau) is even/odd for even/odd l-1.
        do l = 1, size
            do itau = 1, ntau_reduced
                u(itau, l) = u_r_{sig}(itau + {b.ntau_reduced}*(l-1))
                u(ntau-itau+1, l) = (-1)**(l-1) * u_r_{sig}(itau + {b.ntau_reduced}*(l-1))
            end do
        end do

        ! Use the fact U^F_l(iv) is pure imaginary/real for even/odd l-1.
        do l = 1, size, 2
            do ifreq = 1, nfreq_f_reduced
                uhat_f(ifreq, l) = cmplx(0.0, uhat_f_r_{sig}(ifreq + {b.nfreq_f_reduced}*(l-1)), kind(0d0))
            end do
        end do
        do l = 2, size, 2
            do ifreq = 1, nfreq_f_reduced
                uhat_f(ifreq, l) = cmplx(uhat_f_r_{sig}(ifreq + {b.nfreq_f_reduced}*(l-1)), 0.0, kind(0d0))
            end do
        end do
        do l = 1, size
            do ifreq = 1, nfreq_f
                uhat_f(nfreq_f-ifreq+1, l) = conjg(uhat_f(ifreq, l))
            end do
        end do

        ! Use the fact U^B_l(iv) is pure real/imaginary for even/odd l-1
        do l = 1, size, 2
            do ifreq = 1, nfreq_b_reduced
                uhat_b(ifreq, l) = cmplx(uhat_b_r_{sig}(ifreq + {b.nfreq_b_reduced}*(l-1)), 0.0d0, kind(0d0))
            end do
        end do
        do l = 2, size, 2
            do ifreq = 1, nfreq_b_reduced
                uhat_b(ifreq, l) = cmplx(0.0d0, uhat_b_r_{sig}(ifreq + {b.nfreq_b_reduced}*(l-1)), kind(0d0))
            end do
        end do
        do l = 1, size
            do ifreq = 1, nfreq_b
                uhat_b(nfreq_b-ifreq+1, l) = conjg(uhat_b(ifreq, l))
            end do
        end do

        ! Use the fact V_l(omega) is even/odd for even/odd l-1.
        do l = 1, size
            do iomega = 1, nomega_reduced
                v(iomega, l) = v_r_{sig}(iomega + {b.nomega_reduced}*(l-1))
                v(nomega-iomega+1, l) = (-1)**(l-1) * v_r_{sig}(iomega + {b.nomega_reduced}*(l-1))
            end do
            do iomega = 1, nomega
                spr(iomega, l) = - s_{sig}(l) * v(iomega, l)
            end do
        end do

        call init_ir(obj, beta, lambda, eps,&
            s_{sig}, tau_{sig},&
            freq_f_{sig}, freq_b_{sig},&
            u, uhat_f, uhat_b, omega_{sig},&
            v, spr, 1d-20)

        deallocate(u, uhat_f, uhat_b, v, spr)
    end function
"""
    )

    print_vector_data(b.s, f"s_{sig}")
    print_vector_data(b.tau, f"tau_{sig}")
    print_vector_data(b.freq_f, f"freq_f_{sig}")
    print_vector_data(b.freq_b, f"freq_b_{sig}")
    print_vector_data(b.omega, f"omega_{sig}")

    print_vector_data(b.u[0:b.ntau_reduced,:], f"u_r_{sig}")
    print_vector_data((b.uhat_f.real + b.uhat_f.imag)[0:b.nfreq_f_reduced,:], f"uhat_f_r_{sig}")
    print_vector_data((b.uhat_b.real + b.uhat_b.imag)[0:b.nfreq_b_reduced,:], f"uhat_b_r_{sig}")
    print_vector_data(b.v[0:b.nomega_reduced,:], f"v_r_{sig}")

def _array_to_strings(arr, num_elem_str = 3):
    """ Convert array of float or int to a list of strings """
    start = 0
    res = []
    while start < arr.size:
        end = min(start + num_elem_str, arr.size)
        res.append(", ".join(map(_str, arr[start:end])))
        start = end
    return res


def print_vector_data(vec, var_name):
    """ Print initializer of array data """
    vec = np.asfortranarray(vec)
    vec = vec.T.ravel()
    print(
f"""
    subroutine init_{var_name}()
"""
    )
    start = 0
    while start < vec.size:
        end = min(start + NLINE, vec.size)
        sub_vec = vec[start:end]
        print(2*4*" ", f"{var_name}({start+1}:{end}) = (/ &")
        end_str = "&"
        print(", &\n".join(_array_to_strings(sub_vec)) + end_str)
        print(2*4*" " + "/)")
        start = end

    print(
f"""
    end subroutine
"""
    )


if __name__ == '__main__':
    import argparse

    p = argparse.ArgumentParser()

    # accept two lists of arguments
    p.add_argument('--nlambda', nargs="+", type=int)
    p.add_argument('--ndigit', nargs="+", type=int)
    args = p.parse_args()

    nlambda_list = np.array(args.nlambda, dtype=int)
    ndigit_list = np.array(args.ndigit, dtype=int)

    run(nlambda_list, ndigit_list)
