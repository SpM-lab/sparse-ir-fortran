<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>README</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: scroll; scrollbar-width: none; -ms-overflow-style: none;}
.sourceCode::-webkit-scrollbar { 
  display: none;
}
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: scroll; scrollbar-width: none; -ms-overflow-style: none;}
div.sourceCode::-webkit-scrollbar { 
  display: none;
}
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}

body {
font-family: Helvetica, arial, sans-serif;
font-size: 14px;
-webkit-text-size-adjust: 100%;
line-height: 1.6;
padding-top: 10px;
padding-bottom: 10px;
background-color: white;
padding: 30px; }
body > *:first-child {
margin-top: 0 !important; }
body > *:last-child {
margin-bottom: 0 !important; }
a {
color: #4183C4; }
a.absent {
color: #cc0000; }
a.anchor {
display: block;
padding-left: 30px;
margin-left: -30px;
cursor: pointer;
position: absolute;
top: 0;
left: 0;
bottom: 0; }
h1, h2, h3, h4, h5, h6 {
margin: 20px 0 10px;
padding: 0;
font-weight: bold;
cursor: text;
position: relative; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
text-decoration: none; }
h1 tt, h1 code {
font-size: inherit; }
h2 tt, h2 code {
font-size: inherit; }
h3 tt, h3 code {
font-size: inherit;
white-space: normal; }
h4 tt, h4 code {
font-size: inherit; }
h5 tt, h5 code {
font-size: inherit; }
h6 tt, h6 code {
font-size: inherit; }
h1 {
font-size: 28px;
color: black; }
h2 {
font-size: 24px;
border-bottom: 1px solid #cccccc;
color: black; }
h3 {
font-size: 18px; }
h4 {
font-size: 16px; }
h5 {
font-size: 14px; }
h6 {
color: #777777;
font-size: 14px; }
p, blockquote, ul, ol, dl, li, table, pre {
margin: 15px 0; }
hr {
border: 0 none;
color: #cccccc;
height: 4px;
padding: 0; }
body > h2:first-child {
margin-top: 0;
padding-top: 0; }
body > h1:first-child {
margin-top: 0;
padding-top: 0; }
body > h1:first-child + h2 {
margin-top: 0;
padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
margin-top: 0;
padding-top: 0; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
margin-top: 0;
padding-top: 0; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
margin-top: 0; }
li p.first {
display: inline-block; }
ul, ol {
padding-left: 30px; }
ul :first-child, ol :first-child {
margin-top: 0; }
ul :last-child, ol :last-child {
margin-bottom: 0; }
dl {
padding: 0; }
dl dt {
font-size: 14px;
font-weight: bold;
font-style: italic;
padding: 0;
margin: 15px 0 5px; }
dl dt:first-child {
padding: 0; }
dl dt > :first-child {
margin-top: 0; }
dl dt > :last-child {
margin-bottom: 0; }
dl dd {
margin: 0 0 15px;
padding: 0 15px; }
dl dd > :first-child {
margin-top: 0; }
dl dd > :last-child {
margin-bottom: 0; }
blockquote {
border-left: 4px solid #dddddd;
padding: 0 15px;
color: #777777; }
blockquote > :first-child {
margin-top: 0; }
blockquote > :last-child {
margin-bottom: 0; }
table {
padding: 0; }
table tr {
border-top: 1px solid #cccccc;
background-color: white;
margin: 0;
padding: 0; }
table tr:nth-child(2n) {
background-color: #f8f8f8; }
table tr th {
font-weight: bold;
border: 1px solid #cccccc;
text-align: left;
margin: 0;
padding: 6px 13px; }
table tr td {
border: 1px solid #cccccc;
text-align: left;
margin: 0;
padding: 6px 13px; }
table tr th :first-child, table tr td :first-child {
margin-top: 0; }
table tr th :last-child, table tr td :last-child {
margin-bottom: 0; }
img {
max-width: 100%; }
span.frame {
display: block;
overflow: hidden; }
span.frame > span {
border: 1px solid #dddddd;
display: block;
float: left;
overflow: hidden;
margin: 13px 0 0;
padding: 7px;
width: auto; }
span.frame span img {
display: block;
float: left; }
span.frame span span {
clear: both;
color: #333333;
display: block;
padding: 5px 0 0; }
span.align-center {
display: block;
overflow: hidden;
clear: both; }
span.align-center > span {
display: block;
overflow: hidden;
margin: 13px auto 0;
text-align: center; }
span.align-center span img {
margin: 0 auto;
text-align: center; }
span.align-right {
display: block;
overflow: hidden;
clear: both; }
span.align-right > span {
display: block;
overflow: hidden;
margin: 13px 0 0;
text-align: right; }
span.align-right span img {
margin: 0;
text-align: right; }
span.float-left {
display: block;
margin-right: 13px;
overflow: hidden;
float: left; }
span.float-left span {
margin: 13px 0 0; }
span.float-right {
display: block;
margin-left: 13px;
overflow: hidden;
float: right; }
span.float-right > span {
display: block;
overflow: hidden;
margin: 13px auto 0;
text-align: right; }
code {
font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, "Courier New", "Bitstream Vera Sans Mono", 'Lucida Console', monospace;
font-size: inherit;
margin: 0; }
code, tt {
margin: 0 2px;
padding: 0 5px;
white-space: nowrap;
border: 1px solid #eaeaea;
background-color: #f8f8f8;
border-radius: 3px; }
pre code {
margin: 0;
padding: 0;
white-space: pre;
border: none;
background: transparent; }
.highlight pre {
background-color: #f8f8f8;
border: 1px solid #cccccc;
font-size: 13px;
line-height: 19px;
overflow: auto;
padding: 6px 10px;
border-radius: 3px; }
pre {
background-color: #f8f8f8;
border: 1px solid #cccccc;
font-size: 13px;
line-height: 19px;
overflow: auto;
padding: 6px 10px;
border-radius: 3px; }
pre code, pre tt {
background-color: transparent;
border: none; }
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
type="text/javascript"></script>
<!--[if lt IE 9]>
  <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
<![endif]-->
</head>
<body>
<h1 id="sparse-ir-fortran---a-fortran-interface-for-sparse-ir">sparse-ir-fortran - A Fortran interface for sparse-ir</h1>
<p>This library provides a Fortran interface for <code>sparse-ir</code>. At runtime, the installation of <code>sparse-ir</code> is not required.</p>
<p>Before you use it, please install <code>sparse-ir</code> with <code>xprec</code>. The python modules of <code>sparse-ir</code> will be used to generate datasets of IR-basis functions in advance. You can output the datasets in human-readable format or embed them into your Fortran source files.</p>
<h2 id="creating-a-data-file">Creating a data file</h2>
<h3 id="generate-a-data-file">1. Generate a data file:</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">python3</span> dump.py 1e+4 1e-10 ir_nlambda4_ndigit10.dat</span></code></pre></div>
<p>This generates the data file <code>ir_nlambda4_ndigit10.dat</code> containing sparse sampling points and transformation matrices for <span class="math inline">\(\Lambda=10^4\)</span> and <span class="math inline">\(\epsilon = 10^{-10}\)</span> (<span class="math inline">\(\epsilon\)</span> is a cut-off value used when creating IR-basis objects).</p>
<h3 id="build-object-files-and-link-them-to-your-program">2. Build object files and link them to your program:</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">gfortran</span>  -c -o sparse_ir.o sparse_ir.f90</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">gfortran</span>  -c -o sparse_ir_io.o sparse_ir_io.f90</span></code></pre></div>
<p>You do not need <code>sparse_ir_preset.f90</code> if your program reads a data file at runtime.</p>
<h2 id="embedding-data-in-a-fortran-source-file">Embedding data in a Fortran source file</h2>
<p>Data can be embedded in a source file. This allows you to avoid loading data files at runtime.</p>
<h3 id="generate-a-fortran-source-file">1. Generate a fortran source file:</h3>
<p>The following command generates a source file containg data for a matrix of <span class="math inline">\(\Lambda=10^{\mathrm{nlambda}}\)</span> (<span class="math inline">\(\mathrm{nlambda} = 1, 2, 3, 4\)</span>) and <span class="math inline">\(\epsilon=10^{-\mathrm{ndigit}}\)</span> (<span class="math inline">\(\mathrm{ndigit} = 10\)</span>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">python3</span> mk_preset.py --nlambda 1 2 3 4 --ndigit 10 <span class="op">&gt;</span> sparse_ir_preset.f90</span></code></pre></div>
<h3 id="build-object-files-and-link-them-to-your-program-1">2. Build object files and link them to your program:</h3>
<p>The generated file <code>sparse_ir_preset.f90</code> is consisitent with Fortran95 and can be compiled as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">gfortran</span>  -c -o sparse_ir.o sparse_ir.f90</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="op">&gt;</span> <span class="ex">gfortran</span>  -c -o sparse_ir_preset.o sparse_ir_preset.f90</span></code></pre></div>
<p>You do not need <code>sparse_ir_io.f90</code> if your program uses embedded data.</p>
<h2 id="how-to-use-sparse-ir-modules-in-your-fortran-program">How to use sparse-ir modules in your Fortran program</h2>
<p>If your program reads data from the file, you should declare the use of the sparse-ir modules to initiate IR-basis objects as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">program</span> main</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="kw">use</span> sparse_ir</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="kw">use</span> sparse_ir_io</span></code></pre></div>
<p>Or, if you want to use the embed data of IR basis objects, you should do this instead:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">program</span> main</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="kw">use</span> sparse_ir</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="kw">use</span> sparse_ir_preset</span></code></pre></div>
<p>In either case, the derived type of “<code>IR</code>” should be declared.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>  <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="dt">type(IR)</span> <span class="dt">::</span> ir_obj <span class="co">! You can declare with any name you wish.</span></span></code></pre></div>
<p>Hereafter it is assumed that you will set the parameters as <span class="math inline">\(\Lambda = 10^4\)</span>, <span class="math inline">\(\beta = 10^3\)</span>, and <span class="math inline">\(\epsilon = 10^{-10}\)</span>. You can store the IR basis objects into the derived type of “<code>IR</code>” as follows:</p>
<p>Using <code>sparse_ir_io</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>  <span class="dt">double</span> <span class="dt">precision</span> <span class="dt">::</span> beta <span class="co">! inverse temperature</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  ...</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  beta <span class="kw">=</span> <span class="fl">1.0d3</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="fu">open(</span><span class="dv">99</span>, <span class="fu">file</span><span class="kw">=</span><span class="st">&quot;ir_nlambda4_ndigit10.dat&quot;</span>, <span class="fu">status</span><span class="kw">=</span><span class="st">&#39;old&#39;</span><span class="fu">)</span> <span class="co">! Any unit number is OK.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  ir_obj <span class="kw">=</span> read_ir(<span class="dv">99</span>, beta)</span></code></pre></div>
<p>Using <code>sparse_ir_preset</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>  <span class="dt">double</span> <span class="dt">precision</span> <span class="dt">::</span> beta <span class="co">! inverse temperature</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  ...</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  beta <span class="kw">=</span> <span class="fl">1.0d3</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  ir_obj <span class="kw">=</span> mk_ir_preset(<span class="dv">4</span>, <span class="dv">10</span>, beta)</span></code></pre></div>
<p>Here you are ready to use the IR basis objects and call the IR basis subroutines for a given value of <code>beta</code> in your program. If you want to use the IR basis sets with different values of <code>beta</code>, you can reset <code>beta</code> with using the subroutine <code>set_beta</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>  beta <span class="kw">=</span> <span class="fl">2.0d3</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="kw">call</span> set_beta(ir_obj, beta)</span></code></pre></div>
<p>This subroutine updates the objects depending on <code>beta</code>.</p>
<h2 id="available-objects">Available objects</h2>
<h3 id="double-precision-irbeta"><code>DOUBLE PRECISION:: IR%beta</code></h3>
<p>It returns the input value <span class="math inline">\(\beta\)</span> of the functions <code>read_ir</code> or <code>mk_ir_preset</code>.</p>
<h3 id="double-precision-irlambda"><code>DOUBLE PRECISION:: IR%lambda</code></h3>
<p>It returns the input value <span class="math inline">\(\Lambda\)</span> of the functions <code>read_ir</code> or <code>mk_ir_preset</code>. <span class="math inline">\(\Lambda\)</span> determines the sparseness of the IR basis. In the “<code>sparse-ir-fortran</code>” interface, this value determines which dataset to extract among ones with different values of <span class="math inline">\(\Lambda\)</span>.</p>
<h3 id="double-precision-irwmax"><code>DOUBLE PRECISION:: IR%wmax</code></h3>
<p>It returns the value of <span class="math inline">\(\Lambda/\beta\)</span>, where <span class="math inline">\(\beta\)</span> is <code>IR%beta</code>.</p>
<h3 id="double-precision-ireps"><code>DOUBLE PRECISION:: IR%eps</code></h3>
<p>It returns the value of <span class="math inline">\(\epsilon=10^{-\mathrm{ndigit}}\)</span>, where <span class="math inline">\(\mathrm{ndigit}\)</span> is one of input variables of the functions <code>read_ir</code> or <code>mk_ir_preset</code>. The cut-off value <span class="math inline">\(\epsilon\)</span> is used to determine the number of numerically significant singular values when the kernels are SVDecomposed for generating the data of IR basis. In the “<code>sparse-ir-fortran</code>” interface, this value determines which dataset to extract among ones with different cut-offs.</p>
<h3 id="double-precision-irsirsize"><code>DOUBLE PRECISION:: IR%s(IR%size)</code></h3>
<p>It returns the singular values of SVD for generating the data of IR basis.</p>
<h3 id="integer-irsize"><code>INTEGER:: IR%size</code></h3>
<p>It returns the size of <code>IR%s</code>.</p>
<h3 id="double-precision-irtauirntau"><code>DOUBLE PRECISION:: IR%tau(IR%ntau)</code></h3>
<p>It returns the values of <span class="math inline">\(\tau\)</span> of sparse sampling points of imaginary time.</p>
<h3 id="integer-irntau"><code>INTEGER:: IR%ntau</code></h3>
<p>It returns the size of <code>IR%tau</code>.</p>
<h3 id="integer-irfreq_firnfreq_f"><code>INTEGER:: IR%freq_f(IR%nfreq_f)</code></h3>
<p>It returns the odd integers corresponding to sampling Matsubara frequencies for fermionic functions.</p>
<h3 id="integer-irnfreq_f"><code>INTEGER:: IR%nfreq_f</code></h3>
<p>It is the number of sampling Matsubara frequencies for fermionic functions.</p>
<h3 id="integer-irfreq_birnfreq_b"><code>INTEGER:: IR%freq_b(IR%nfreq_b)</code></h3>
<p>It returns the even integers corresponding to sampling Matsubara frequencies for bosonic functions.</p>
<h3 id="integer-irnfreq_b"><code>INTEGER:: IR%nfreq_b</code></h3>
<p>It is the number of sampling Matsubara frequencies for bosonic functions.</p>
<h3 id="typedecomposedmatrix-iruhat_f"><code>TYPE(DecomposedMatrix):: IR%uhat_f</code></h3>
<p>It refers to the derived type of <code>DecomposedMatrix</code> which contains <code>IR%uhat_f%a</code>, <code>IR%uhat_f%inv_s</code>, <code>IR%uhat_f%ut</code>, and <code>IR%uhat_f%v</code>. When a derived type of <code>IR</code> is defined for a given <code>beta</code>, SVD of <span class="math inline">\(\{\hat{U}_l(\mathrm{i}\nu_n)\}\)</span> for a given <code>beta</code> is performed to define <code>IR%uhat_f%inv_s</code>, <code>IR%uhat_f%ut</code>, and <code>IR%uhat_f%v</code>, which are used in subroutines <code>fit_matsubara_f</code> and <code>evaluate_matsubara_f</code>. The basis functions on fermionic sampling Matsubara frequencies is SVDecomposed in advance as follows:</p>
<p><span class="math display">\[
\begin{align*}
\hat{U}_l(\mathrm{i}\nu_n) &amp;= A_{nl} \\
&amp;=\sum_{r,r&#39;}U_{nr} \Sigma_{rr&#39;} (V^\mathrm{T})_{r&#39;l} \\
(A &amp;= U \Sigma V^\mathrm{T}),
\end{align*}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\Sigma_{rr&#39;} = \sigma_r\delta_{r,r&#39;}~  (\sigma_r \neq 0).
\]</span></p>
<p>If the following fitting problem is given for a certain fermionic function <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> defined on Matsubara frequencies,</p>
<p><span class="math display">\[
\sum_{l}\hat{U}_l(\mathrm{i}\nu_n)G_l\approx G(\mathrm{i}\nu_n),
\]</span></p>
<p>you can solve the problem using <code>fit_matsubara_f</code> as follows:</p>
<p><span class="math display">\[
G_l\approx \sum_{r, n}V_{lr}\Sigma^+_{rr}(U^\mathrm{T})_{rn}G(\mathrm{i}\nu_n).
\]</span></p>
<p><code>IR%uhat_f%a</code>, <code>IR%uhat_f%ut</code>, and <code>IR%uhat_f%v</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays corresponding to <span class="math inline">\(A\)</span>, <span class="math inline">\(U^\mathrm{T}\)</span>, and <span class="math inline">\(V\)</span>, respectively. <code>IR%uhat_f%inv_s</code> is the 1-dimensional <code>DOUBLE PRECISION</code> array storing the components of the diagonal matrix <span class="math inline">\(\Sigma^+\)</span>, namely <span class="math inline">\(\{1/\sigma_r\}\)</span>. <code>IR%uhat_f%ns</code> is the size of <code>IR%uhat_f%inv_s</code>. <code>IR%uhat_f%m</code> and <code>IR%uhat_f%n</code> equal to <code>IR%nfreq_f</code> and <code>IR%size</code>, respectively.</p>
<h3 id="typedecomposedmatrix-iruhat_b"><code>TYPE(DecomposedMatrix):: IR%uhat_b</code></h3>
<p>It refers to the derived type of <code>DecomposedMatrix</code> which contains <code>IR%uhat_b%a</code>, <code>IR%uhat_b%inv_s</code>, <code>IR%uhat_b%ut</code>, and <code>IR%uhat_b%v</code>, which are used in subroutines <code>fit_matsubara_b</code> and <code>evaluate_matsubara_b</code>. <code>IR%u%a</code> corresponds to <span class="math inline">\(\{\hat{U}_l(\mathrm{i}\nu_n)\}\)</span> defined on bosonic Matsubara frequencies. This derived type is similar to <code>IR%uhat_f</code>, so please see the description of <code>IR%uhat_f</code> as well.</p>
<h3 id="typedecomposedmatrix-iru"><code>TYPE(DecomposedMatrix):: IR%u</code></h3>
<p>It refers to the derived type of <code>DecomposedMatrix</code> which contains <code>IR%u%a</code>, <code>IR%u%inv_s</code>, <code>IR%u%ut</code>, and <code>IR%u%v</code>, which are used in subroutines <code>fit_matsubara_b</code> and <code>evaluate_matsubara_b</code>. <code>IR%u%a</code> corresponds to <span class="math inline">\(\{U_l(\tau_m)\}\)</span> on sampling points of imaginary time. This derived type is similar to <code>IR%uhat_f</code>, so please see the description of <code>IR%uhat_f</code> as well.</p>
<h2 id="subroutines">Subroutines</h2>
<h3 id="subroutine-set_beta"><code>SUBROUTINE set_beta</code></h3>
<p>The subroutine (re)sets the value of <code>beta</code>. <code>IR%u_data</code>, <code>IR%uhat_f_data</code>, and <code>IR%uhat_b_data</code> store the dimensionless forms of the IR-basis functions. This subroutine replaces the dimensionless variable <code>IR%x</code> with the <code>IR%beta</code> of them. This subroutine also does SVD of the basis functions.</p>
<p>The usage is</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">call</span> set_beta(obj, beta)</span></code></pre></div>
<p>where <code>beta</code> is a <code>DOUBLE PRECISION</code> variable and <code>obj</code> is the derived type of “<code>IR</code>”. In this subroutine, the objects in <code>obj</code> depending on <code>beta</code> are updated.</p>
<h3 id="subroutine-fit_matsubara_f"><code>SUBROUTINE fit_matsubara_f</code></h3>
<p>The subroutine fits a set of expansion coefficients <span class="math inline">\(G_l\)</span> to a given fermionic function <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> on sampling Matsubara frequencies by using SVD.</p>
<p><span class="math display">\[
\begin{align*}
G_l = \underset{G_l}{{\rm argmin}}\sum_{n}\left|G(\mathrm{i}\nu_n) - \sum_{l}\hat{U}_l(\mathrm{i}\nu_n)G_l \right|^2
\end{align*}
\]</span></p>
<p>The usage is</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">call</span> fit_matsubara_f(obj, g_in, g_out)</span></code></pre></div>
<p>where <code>g_in</code> and <code>g_out</code> correspond to <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> and <span class="math inline">\(G_l\)</span>, respectively. <code>obj</code> is the derived type of “<code>IR</code>”, and <code>g_in</code> and <code>g_out</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays. The inputs are <code>obj</code> and <code>g_in</code> and the output is <code>g_out</code>. Before calling this subroutine, you should reshape the array of <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> to a 2-dimensional array whose last axis corresponds to <span class="math inline">\(l\)</span> and allocate <code>g_out</code> with appropriate shape. That is, <code>g_in</code> and <code>g_out</code> should be allocated so as to have shapes of <code>(**, obj%nfreq_f)</code> and <code>(**, obj%size)</code>, respectively.</p>
<h3 id="subroutine-fit_matsubara_b"><code>SUBROUTINE fit_matsubara_b</code></h3>
<p>The subroutine fits a set of expansion coefficients <span class="math inline">\(G_l\)</span> to a given bosonic function <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> on sampling Matsubara frequencies by using SVD.</p>
<p><span class="math display">\[
\begin{align*}
G_l = \underset{G_l}{{\rm argmin}}\sum_{n}\left|G(\mathrm{i}\nu_n) - \sum_{l}\hat{U}_l(\mathrm{i}\nu_n)G_l \right|^2
\end{align*}
\]</span></p>
<p>The usage is</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">call</span> fit_matsubara_b(obj, g_in, g_out)</span></code></pre></div>
<p>where <code>g_in</code> and <code>g_out</code> correspond to <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> and <span class="math inline">\(G_l\)</span>, respectively. <code>obj</code> is the derived type of “<code>IR</code>”, and <code>g_in</code> and <code>g_out</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays. The inputs are <code>obj</code> and <code>g_in</code> and the output is <code>g_out</code>. Before calling this subroutine, you should reshape the array of <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> to a 2-dimensional array whose last axis corresponds to <span class="math inline">\(l\)</span> and allocate <code>g_out</code> with appropriate shape. That is, <code>g_in</code> and <code>g_out</code> should be allocated so as to have shapes of <code>(**, obj%nfreq_b)</code> and <code>(**, obj%size)</code>, respectively.</p>
<h3 id="subroutine-fit_tau"><code>SUBROUTINE fit_tau</code></h3>
<p>The subroutine fits a set of expansion coefficients <span class="math inline">\(G_l\)</span> to a given imaginary-time function <span class="math inline">\(G(\tau_m)\)</span> on sampling points by using SVD.</p>
<p><span class="math display">\[
\begin{align*}
G_l = \underset{G_l}{{\rm argmin}}\sum_{m}\left|G(\tau_m) - \sum_{l}U_l(\tau_m)G_l \right|^2
\end{align*}
\]</span></p>
<p>The usage is</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">call</span> fit_tau(obj, g_in, g_out)</span></code></pre></div>
<p>where <code>g_in</code> and <code>g_out</code> correspond to <span class="math inline">\(G(\tau_m)\)</span> and <span class="math inline">\(G_l\)</span>, respectively. <code>obj</code> is the derived type of “<code>IR</code>”, and <code>g_in</code> and <code>g_out</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays. The inputs are <code>obj</code> and <code>g_in</code> and the output is <code>g_out</code>. Before calling this subroutine, you should reshape the array of <span class="math inline">\(G(\tau_m)\)</span> to a 2-dimensional array whose last axis corresponds to <span class="math inline">\(l\)</span> and allocate <code>g_out</code> with appropriate shape. That is, <code>g_in</code> and <code>g_out</code> should be allocated so as to have shapes of <code>(**, obj%ntau)</code> and <code>(**, obj%size)</code>, respectively.</p>
<h3 id="subroutine-evaluate_matsubara_f"><code>SUBROUTINE evaluate_matsubara_f</code></h3>
<p>This subroutine reconstructs a fermionic function <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> on sampling Matsubara frequencies from a given set of expansion coefficients <span class="math inline">\(G_l\)</span> as follows:</p>
<p><span class="math display">\[
\begin{align*}
G(\mathrm{i}\nu_n) = \sum_{l}\hat{U}_l(\mathrm{i}\nu_n)G_l
\end{align*}
\]</span></p>
<p>The usage is</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">call</span> evaluate_matsubara_f(obj, g_in, g_out)</span></code></pre></div>
<p>where <code>g_in</code> and <code>g_out</code> correspond to <span class="math inline">\(G_l\)</span> and <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span>, respectively. <code>obj</code> is the derived type of “<code>IR</code>”, and <code>g_in</code> and <code>g_out</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays. The inputs are <code>obj</code> and <code>g_in</code> and the output is <code>g_out</code>. Before calling this subroutine, you should reshape the array of <span class="math inline">\(G_l\)</span> to a 2-dimensional array whose last axis corresponds to <span class="math inline">\(\mathrm{i}\nu_n\)</span> and allocate <code>g_out</code> with appropriate shape. That is, <code>g_in</code> and <code>g_out</code> should be allocated so as to have shapes of <code>(**, obj%size)</code> and <code>(**, obj%nfreq_f)</code>, respectively.</p>
<h3 id="subroutine-evaluate_matsubara_b"><code>SUBROUTINE evaluate_matsubara_b</code></h3>
<p>This subroutine reconstructs a bosonic function <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span> on sampling Matsubara frequencies from a given set of expansion coefficients <span class="math inline">\(G_l\)</span> as follows:</p>
<p><span class="math display">\[
\begin{align*}
G(\mathrm{i}\nu_n) = \sum_{l}\hat{U}_l(\mathrm{i}\nu_n)G_l
\end{align*}
\]</span></p>
<p>The usage is</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">call</span> evaluate_matsubara_b(obj, g_in, g_out)</span></code></pre></div>
<p>where <code>g_in</code> and <code>g_out</code> correspond to <span class="math inline">\(G_l\)</span> and <span class="math inline">\(G(\mathrm{i}\nu_n)\)</span>, respectively. <code>obj</code> is the derived type of “<code>IR</code>”, and <code>g_in</code> and <code>g_out</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays. The inputs are <code>obj</code> and <code>g_in</code> and the output is <code>g_out</code>. Before calling this subroutine, you should reshape the array of <span class="math inline">\(G_l\)</span> to a 2-dimensional array whose last axis corresponds to <span class="math inline">\(\mathrm{i}\nu_n\)</span> and allocate <code>g_out</code> with appropriate shape. That is, <code>g_in</code> and <code>g_out</code> should be allocated so as to have shapes of <code>(**, obj%size)</code> and <code>(**, obj%nfreq_b)</code>, respectively.</p>
<h3 id="subroutine-evaluate_tau"><code>SUBROUTINE evaluate_tau</code></h3>
<p>This subroutine reconstructs a function <span class="math inline">\(G(\tau_m)\)</span> on sampling points of imaginary time from a given set of expansion coefficients <span class="math inline">\(G_l\)</span> as follows:</p>
<p><span class="math display">\[
\begin{align*}
G(\tau_m) = \sum_{l}U_l(\tau_m)G_l
\end{align*}
\]</span></p>
<p>The usage is</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode fortran"><code class="sourceCode fortran"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">call</span> evaluate_tau(obj, g_in, g_out)</span></code></pre></div>
<p>where <code>g_in</code> and <code>g_out</code> correspond to <span class="math inline">\(G_l\)</span> and <span class="math inline">\(G(\tau_m)\)</span>, respectively. <code>obj</code> is the derived type of “<code>IR</code>”, and <code>g_in</code> and <code>g_out</code> are 2-dimensional <code>COMPLEX(KIND(0D0))</code> arrays. The inputs are <code>obj</code> and <code>g_in</code> and the output is <code>g_out</code>. Before calling this subroutine, you should reshape the array of <span class="math inline">\(G_l\)</span> to a 2-dimensional array whose last axis corresponds to <span class="math inline">\(\mathrm{i}\nu_n\)</span> and allocate <code>g_out</code> with appropriate shape. That is, <code>g_in</code> and <code>g_out</code> should be allocated so as to have shapes of <code>(**, obj%size)</code> and <code>(**, obj%ntau)</code>, respectively.</p>
</body>
</html>
